#!/usr/bin/env bash

# ABOUTME: Backs up existing dotfiles before installation
# ABOUTME: Provides safe restoration mechanism for dotfiles management

set -euo pipefail

# Configuration
BACKUP_DIR="$HOME/.dotfiles-backup-$(date +%Y%m%d-%H%M%S)"
DOTFILES_DIR="$HOME/.dotfiles"

# Colors for output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly NC='\033[0m' # No Color

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Files that get symlinked from terminal.yml
declare -A FILES_TO_BACKUP=(
    ["$HOME/.shell"]="shell directory"
    ["$HOME/.zshrc"]="zsh configuration"
    ["$HOME/.zshenv"]="zsh environment"
    ["$HOME/.hushlogin"]="hush login file"
    ["$HOME/.zplugrc"]="zplug configuration"
    ["$HOME/.tmux.conf"]="tmux configuration"
    ["$HOME/.gitconfig"]="git configuration"
    ["$HOME/.gitignore_global"]="global gitignore"
    ["$HOME/.gitattributes_global"]="global gitattributes"
    ["$HOME/.config/helix/config.toml"]="helix editor config"
    ["$HOME/.claude"]="Claude Code configuration"
)

backup_file() {
    local source_file="$1"
    local description="$2"
    
    if [[ -e "$source_file" ]]; then
        local relative_path="${source_file#$HOME/}"
        local backup_path="$BACKUP_DIR/$relative_path"
        local backup_dir=$(dirname "$backup_path")
        
        mkdir -p "$backup_dir"
        
        if [[ -L "$source_file" ]]; then
            # It's a symlink, backup the link itself
            cp -P "$source_file" "$backup_path"
            log_info "Backed up symlink: $description"
        elif [[ -d "$source_file" ]]; then
            # It's a directory
            cp -R "$source_file" "$backup_path"
            log_info "Backed up directory: $description"
        else
            # It's a regular file
            cp "$source_file" "$backup_path"
            log_info "Backed up file: $description"
        fi
    else
        log_warn "File not found, skipping: $description ($source_file)"
    fi
}

create_restore_script() {
    local restore_script="$BACKUP_DIR/restore.sh"
    
    cat > "$restore_script" << 'EOF'
#!/usr/bin/env bash

# ABOUTME: Restores dotfiles from backup
# ABOUTME: Auto-generated restoration script for dotfiles backup

set -euo pipefail

BACKUP_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
HOME_DIR="$HOME"

echo "Restoring dotfiles from backup: $BACKUP_DIR"
echo "WARNING: This will overwrite current dotfiles!"
read -p "Continue? (y/N): " -n 1 -r
echo

if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    echo "Restore cancelled."
    exit 1
fi

cd "$BACKUP_DIR"
find . -type f -not -name "restore.sh" -not -name "backup-manifest.txt" | while read -r file; do
    # Remove leading ./
    relative_path="${file#./}"
    target="$HOME_DIR/$relative_path"
    target_dir=$(dirname "$target")
    
    echo "Restoring: $relative_path"
    mkdir -p "$target_dir"
    cp "$file" "$target"
done

echo "Restore completed successfully!"
EOF

    chmod +x "$restore_script"
    log_info "Created restore script: $restore_script"
}

create_manifest() {
    local manifest="$BACKUP_DIR/backup-manifest.txt"
    
    cat > "$manifest" << EOF
Dotfiles Backup Manifest
========================

Backup Date: $(date)
Backup Directory: $BACKUP_DIR
Dotfiles Source: $DOTFILES_DIR

Files Backed Up:
EOF

    for file_path in "${!FILES_TO_BACKUP[@]}"; do
        local description="${FILES_TO_BACKUP[$file_path]}"
        if [[ -e "$file_path" ]]; then
            echo "  ✓ $description ($file_path)" >> "$manifest"
        else
            echo "  ✗ $description ($file_path) - NOT FOUND" >> "$manifest"
        fi
    done
    
    echo "" >> "$manifest"
    echo "To restore this backup, run: $BACKUP_DIR/restore.sh" >> "$manifest"
    
    log_info "Created backup manifest: $manifest"
}

main() {
    log_info "Starting dotfiles backup..."
    log_info "Backup directory: $BACKUP_DIR"
    
    # Create backup directory
    mkdir -p "$BACKUP_DIR"
    
    # Backup each file
    for file_path in "${!FILES_TO_BACKUP[@]}"; do
        local description="${FILES_TO_BACKUP[$file_path]}"
        backup_file "$file_path" "$description"
    done
    
    # Create restore script and manifest
    create_restore_script
    create_manifest
    
    log_info "Backup completed successfully!"
    log_info "Backup location: $BACKUP_DIR"
    log_info "To restore: $BACKUP_DIR/restore.sh"
    
    # Store latest backup location for easy access
    echo "$BACKUP_DIR" > "$HOME/.dotfiles-latest-backup"
}

# Show help
if [[ "${1:-}" == "--help" ]] || [[ "${1:-}" == "-h" ]]; then
    cat << EOF
Dotfiles Backup Script

Usage: $0 [OPTIONS]

This script backs up your current dotfiles configuration before installing
new dotfiles. It creates a timestamped backup directory with:
  - All current dotfiles that would be replaced
  - A restore script to rollback changes
  - A manifest of what was backed up

Options:
  -h, --help    Show this help message

The backup will be created at:
  ~/.dotfiles-backup-YYYYMMDD-HHMMSS/

To restore from a backup:
  ~/.dotfiles-backup-YYYYMMDD-HHMMSS/restore.sh
EOF
    exit 0
fi

main "$@"